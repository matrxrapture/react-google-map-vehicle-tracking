[{"/home/elton/react-google-map-vehicle-tracking/web_app/src/index.js":"1","/home/elton/react-google-map-vehicle-tracking/web_app/src/App.js":"2","/home/elton/react-google-map-vehicle-tracking/web_app/src/reportWebVitals.js":"3","/home/elton/react-google-map-vehicle-tracking/web_app/src/hooks/useFetch.js":"4","/home/elton/react-google-map-vehicle-tracking/web_app/src/components/Header/Header.js":"5","/home/elton/react-google-map-vehicle-tracking/web_app/src/components/gMap/Map.js":"6","/home/elton/react-google-map-vehicle-tracking/web_app/src/components/gMap/config.js":"7"},{"size":455,"mtime":1688520536719,"results":"8","hashOfConfig":"9"},{"size":1311,"mtime":1688539248209,"results":"10","hashOfConfig":"9"},{"size":362,"mtime":1688520536719,"results":"11","hashOfConfig":"9"},{"size":861,"mtime":1688520536719,"results":"12","hashOfConfig":"9"},{"size":2406,"mtime":1688533195999,"results":"13","hashOfConfig":"9"},{"size":6406,"mtime":1688520536719,"results":"14","hashOfConfig":"9"},{"size":158,"mtime":1688529484188,"results":"15","hashOfConfig":"9"},{"filePath":"16","messages":"17","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"17rtu9e",{"filePath":"18","messages":"19","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"20"},{"filePath":"21","messages":"22","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"23","messages":"24","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"25","messages":"26","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"27","messages":"28","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"29"},{"filePath":"30","messages":"31","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/home/elton/react-google-map-vehicle-tracking/web_app/src/index.js",[],"/home/elton/react-google-map-vehicle-tracking/web_app/src/App.js",["32"],"import React from 'react';\nimport './App.css';\nimport WrappedMap from './components/gMap/Map';\nimport data from './data.json'\nimport config from './components/gMap/config';\nimport useFetch from './hooks/useFetch';\nimport Header from './components/Header/Header';\nimport Box from '@mui/material/Box';\nimport LinearProgress from '@mui/material/LinearProgress';\n\nfunction App() {\n  \n  const { data: paths} = useFetch('https://61a4a0604c822c0017041d33.mockapi.io/shuttle/v1/path');\n  // const  { data: paths}  = Array.from(data).map(data)\n  const { data: stops } = useFetch('https://61a4a0604c822c0017041d33.mockapi.io/shuttle/v1/stops');\n  const mapURL = `https://maps.googleapis.com/maps/api/js?v=3.exp&libraries=geometry,drawing,places&key=${config.mapsKey}`;\n  \n  return (\n    <div className=\"App\">\n      \n      <Header/>\n      \n      { paths && stops ?\n        <WrappedMap\n            paths={paths}\n            stops={stops}\n            googleMapURL={mapURL}\n            loadingElement={<div style={{ height: `100%` }} />}\n            containerElement={<div className='mapContainer'  />}\n            mapElement={<div style={{ height: `100%` }} />}\n          />\n          : \n          <Box sx={{ width: '100%' }}>\n            <LinearProgress />\n          </Box>\n        }\n    </div>\n  );\n}\n\nexport default App;\n","/home/elton/react-google-map-vehicle-tracking/web_app/src/reportWebVitals.js",[],"/home/elton/react-google-map-vehicle-tracking/web_app/src/hooks/useFetch.js",[],"/home/elton/react-google-map-vehicle-tracking/web_app/src/components/Header/Header.js",[],"/home/elton/react-google-map-vehicle-tracking/web_app/src/components/gMap/Map.js",["33","34","35"],"import React, { useEffect, useState, useCallback } from 'react';\nimport {\n  GoogleMap,\n  withScriptjs,\n  withGoogleMap,\n  Marker,\n  Polyline\n} from 'react-google-maps';\nimport Button from '@mui/material/Button';\nimport Card from '@mui/material/Card';\nimport '../../App.css';\n\nconst Map = ({paths, stops})=> {\n    \n   \n    const [progress, setProgress] = useState(null);\n    const velocity = 27; // 100km per hour\n    let initialDate;\n    let interval = null;\n    const icon1 = {\n        url: \"https://images.vexels.com/media/users/3/154573/isolated/preview/bd08e000a449288c914d851cb9dae110-hatchback-car-top-view-silhouette-by-vexels.png\",\n        scaledSize: new window.google.maps.Size(40, 40),\n        anchor: new window.google.maps.Point(20, 20),\n        scale: 0.7,\n      };\n    \n    const center = parseInt(paths.length / 2 );\n    const centerPathLat = paths[center].lat;\n    const centerpathLng = paths[center + 5].lng;\n    \n    useEffect(() => {\n        calculatePath();\n\n        return () => {\n            console.log(\"CLEAR........\");\n            interval && window.clearInterval(interval);\n        }\n    }, [paths]);\n\n    const getDistance = () => {\n        // seconds between when the component loaded and now\n        const differentInTime = (new Date() - initialDate) / 1000; // pass to seconds\n        return differentInTime * velocity; // d = v*t -- thanks Newton!\n    };\n    \n    const moveObject = () => {\n        const distance = getDistance();\n        if (!distance) {\n          return;\n        }\n    \n        let progress = paths.filter(\n          (coordinates) => coordinates.distance < distance\n        );\n    \n        const nextLine = paths.find(\n          (coordinates) => coordinates.distance > distance\n        );\n    \n        \n        if (!nextLine) {\n          setProgress(progress)\n          window.clearInterval(interval);\n          console.log(\"Trip Completed!! Thank You !!\")\n          return; // it's the end!\n        }\n        const lastLine = progress[progress.length - 1];\n    \n        const lastLineLatLng = new window.google.maps.LatLng(\n          lastLine.lat,\n          lastLine.lng\n        );\n    \n        const nextLineLatLng = new window.google.maps.LatLng(\n          nextLine.lat,\n          nextLine.lng\n        );\n    \n        // distance of this line\n        const totalDistance = nextLine.distance - lastLine.distance;\n        const percentage = (distance - lastLine.distance) / totalDistance;\n    \n        const position = window.google.maps.geometry.spherical.interpolate(\n          lastLineLatLng,\n          nextLineLatLng,\n          percentage\n        );\n\n        mapUpdate();\n        setProgress(progress.concat(position))\n    };\n\n    const calculatePath = () => {\n        paths = paths.map((coordinates, i, array) => {\n          if (i === 0) {\n            return { ...coordinates, distance: 0 }; // it begins here!\n          }\n          const { lat: lat1, lng: lng1 } = coordinates;\n          const latLong1 = new window.google.maps.LatLng(lat1, lng1);\n    \n          const { lat: lat2, lng: lng2 } = array[0];\n          const latLong2 = new window.google.maps.LatLng(lat2, lng2);\n    \n          // in meters:\n          const distance = window.google.maps.geometry.spherical.computeDistanceBetween(\n            latLong1,\n            latLong2\n          );\n    \n          return { ...coordinates, distance };\n        });\n    };\n    \n    const startSimulation = useCallback(\n        () => {\n            if(interval) {\n                window.clearInterval(interval);\n            }\n            setProgress(null);\n            initialDate = new Date();\n            interval = window.setInterval(moveObject, 1000);\n        },\n        [interval, initialDate],\n    );\n\n    const mapUpdate = () => {\n        const distance = getDistance();\n        if (!distance) {\n            return;\n        }\n\n        let progress = paths.filter(\n            (coordinates) => coordinates.distance < distance\n        );\n\n        const nextLine = paths.find(\n            (coordinates) => coordinates.distance > distance\n        );\n\n        let point1, point2;\n\n        if (nextLine) {\n            point1 = progress[progress.length - 1];\n            point2 = nextLine;\n        } else {\n            // it's the end, so use the latest 2\n            point1 = progress[progress.length - 2];\n            point2 = progress[progress.length - 1];\n        }\n\n        const point1LatLng = new window.google.maps.LatLng(point1.lat, point1.lng);\n        const point2LatLng = new window.google.maps.LatLng(point2.lat, point2.lng);\n\n        const angle = window.google.maps.geometry.spherical.computeHeading(\n            point1LatLng,\n            point2LatLng\n        );\n        const actualAngle = angle - 90;\n\n        const marker = document.querySelector(`[src=\"${icon1.url}\"]`);\n\n        if (marker) {\n            // when it hasn't loaded, it's null\n            marker.style.transform = `rotate(${actualAngle}deg)`;\n        }\n    }\n    \n    return(\n      <Card variant=\"outlined\">\n        <div className='btnCont'>\n          <Button variant=\"contained\" onClick={startSimulation}>Start Simulation</Button>\n        </div>\n        \n        <div className='gMapCont'>\n          <GoogleMap\n              defaultZoom={17}\n              defaultCenter={{ lat: centerPathLat, lng: centerpathLng }}\n          >\n            <Polyline\n                path={paths}\n                options={{\n                strokeColor: \"#0088FF\",\n                strokeWeight: 6,\n                strokeOpacity: 0.6,\n                defaultVisible: true,\n                }}\n            />\n\n            {stops.data.map((stop, index) => (\n\n                <Marker\n                    key={index}\n                    position={{\n                        lat: stop.lat,\n                        lng: stop.lng\n                    }}\n                    title={stop.id}\n                    label={`${index + 1}`}\n                />\n            ))}\n\n            {progress && (\n                <>\n                <Polyline\n                    path={progress}\n                    options={{ strokeColor: \"orange\" }}\n                />\n\n                <Marker\n                    icon={icon1}\n                    position={progress[progress.length - 1]}\n                />\n                </>\n            )}\n          </GoogleMap>\n        </div>\n      </Card>  \n    )\n};\n\nexport default withScriptjs(\n  withGoogleMap(\n    Map\n  )\n)","/home/elton/react-google-map-vehicle-tracking/web_app/src/components/gMap/config.js",[],{"ruleId":"36","severity":1,"message":"37","line":4,"column":8,"nodeType":"38","messageId":"39","endLine":4,"endColumn":12},{"ruleId":"40","severity":1,"message":"41","line":38,"column":8,"nodeType":"42","endLine":38,"endColumn":15,"suggestions":"43"},{"ruleId":"40","severity":1,"message":"44","line":120,"column":27,"nodeType":"45","endLine":120,"endColumn":37},{"ruleId":"40","severity":1,"message":"46","line":121,"column":24,"nodeType":"47","endLine":121,"endColumn":60},"no-unused-vars","'data' is defined but never used.","Identifier","unusedVar","react-hooks/exhaustive-deps","React Hook useEffect has missing dependencies: 'calculatePath' and 'interval'. Either include them or remove the dependency array.","ArrayExpression",["48"],"Assignments to the 'initialDate' variable from inside React Hook useCallback will be lost after each render. To preserve the value over time, store it in a useRef Hook and keep the mutable value in the '.current' property. Otherwise, you can move this variable directly inside useCallback.","NewExpression","Assignments to the 'interval' variable from inside React Hook useCallback will be lost after each render. To preserve the value over time, store it in a useRef Hook and keep the mutable value in the '.current' property. Otherwise, you can move this variable directly inside useCallback.","CallExpression",{"desc":"49","fix":"50"},"Update the dependencies array to be: [calculatePath, interval, paths]",{"range":"51","text":"52"},[1118,1125],"[calculatePath, interval, paths]"]